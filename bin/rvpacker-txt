#!/usr/bin/env ruby
require 'RGSS'
require 'optparse'

$logging = false
$shuffle = 0
$no = [true, true, true, true] # 0 is whether to process maps, 1 is other, 2 is system, 3 is scripts

opts = {}
OptionParser.new do |options|
    options.banner = "This tool allows to parse RPG Maker project to .txt files and back.\n\nUsage: rvpacker-txt COMMAND [options]\n\nCOMMANDS:\n    read - Parses RPG Maker game files to .txt\n    write - Writes parsed files back to their initial form\nOPTIONS:\n"

    options.on('-d', '--input-dir DIRECTORY', 'Input directory of RPG Maker project.',
               'Must contain "Data" or "original" folder to read,',
               'and additionally "translation" with "maps" and  "other" subdirectories to write.') do |dir|
        opts[:input_dir] = dir
    end

    options.on('--no', "Don't process specified files.", 'Takes multiple values separated by a comma.', 'Allowed values: maps, other, system, plugins') do |files|
        actual_files = files.split(',')

        actual_files.each do |file|
            case file
                when "maps"
                    $no[0] = false
                when "other"
                    $no[1] = false
                when "system"
                    $no[2] = false
                when "scripts"
                    $no[3] = false
                else
                    nil
            end
        end
    end

    options.on('-s', '--shuffle NUMBER', 'At value 1: Shuffles all lines in strings, at value 2: shuffles all lines and words in strings.') do |number|
        $shuffle = number
    end

    options.on('-l', '--log', 'Log information while processing.') do
        $logging = true
    end

    options.on_tail('-h', '--help', 'Show help message.') do
        puts options
        exit
    end
end.parse!(ARGV)

if ARGV.empty?
    puts 'COMMAND argument is required.'
    exit
end

opts[:action] = ARGV.shift

unless %w[read write].include?(opts[:action])
    puts 'Invalid command. Allowed commands are: read, write.'
    exit
end

project_types = { 'vx' => :vx, 'ace' => :ace, 'xp' => :xp }

directory = opts[:input_dir]
raise "#{directory} not found" unless File.exist?(directory)

original_directory = Dir.foreach(directory).find { |filename| filename.downcase == 'original' } ||
    Dir.foreach(directory).find { |filename| filename.downcase == 'data' }
raise '"Data" or "original" directory not found within input directory.' if original_directory.nil?

types = %w[vx ace xp]

type = types.find do |type_|
    case type_
        when 'xp'
            break project_types[type_] if File.exist?(File.join(directory, original_directory, 'System.rxdata'))
        when 'vx'
            break project_types[type_] if File.exist?(File.join(directory, original_directory, 'System.rvdata'))
        when 'ace'
            break project_types[type_] if File.exist?(File.join(directory, original_directory, 'System.rvdata2'))
        else
            break nil
    end
end

raise 'Couldn\'t determine project engine.' if type.nil?

RGSS.serialize(type, opts[:action], directory, original_directory)
