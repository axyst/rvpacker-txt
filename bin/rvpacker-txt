#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'fileutils'

require 'classes'

def self.parse_options
    options = { disable_processing: {}, input_dir: './', output_dir: './', shuffle_level: 0 }

    read_command_description = 'Parses files from "original" or "data" folders of input directory to "translation" folder of output directory.'
    write_command_description = 'Writes translated files using original files from "original" or "data" folder of input directory and writes results to "output" folder of output directory.'
    banner_text = "This tool allows to parse RPG Maker games to .txt files and write them back to their initial form.\n\nUsage: rvpacker-txt COMMAND [options]\n\nCOMMANDS:\n    read - #{read_command_description}\n    write - #{write_command_description}\nOPTIONS:\n"

    OptionParser.new(banner_text) do |cmd|
        cmd.on('-i', '--input-dir PATH', String,
               'When reading: Input directory, containing folders "original" or "data" with original game files.',
               'When writing: Input directory, containing folders "original" or "data" and "translation" with original game files and .txt files with translation respectively.') do |dir|
            options[:input_dir] = File.exist?(dir) ? File.realpath(dir) : (raise "#{dir} not found")
            options[:output_dir] = options[:input_dir]
        end

        cmd.on('-o', '--output-dir PATH', String,
               'When reading: Output directory, where an "output" folder will be created, containing compiled RPG Maker files with your translation.',
               'When writing: Output directory, where a "translation" folder will be created, containing parsed .txt files with the text from the game.') do |dir|
            options[:output_dir] = File.exist?(dir) ? File.realpath(dir) : (raise "#{dir} not found")
        end

        cmd.on('--disable-processing FILES', Array,
               'Skips processing the specified files.',
               'Example: --disable-processing=maps,other,system.',
               '[Allowed values: maps, other, system, scripts]') do |files|
            files.each do |file|
                files = %w[maps other system scripts]
                index = files.find_index(file)
                options[:disable_processing][files[index]] = true if index
            end
        end

        cmd.on('-s', '--shuffle-level NUMBER', Integer,
               'With value 1, shuffles all translation lines. With value 2, shuffles all words and lines in translation text.',
               'Example: --shuffle-level 1.',
               '[Allowed values: 0, 1, 2]',
               '[Default value: 0]',
               '[Write flag]') do |num|
            raise 'Allowed values: 0, 1, 2' if num > 2
            options[:shuffle_level] = num
        end

        cmd.on('--disable-custom-processing', 'Disables built-in custom parsing/writing for some games.') do
            options[:disable_custom_processing] = true
        end

        cmd.on('-l', '--log', 'Enables logging.') do
            options[:logging] = true
        end

        cmd.on('-f', '--force',
               'Force rewrite all files. Cannot be used with --append.',
               'USE WITH CAUTION!',
               '[Read flag]') do
            options[:force] = true
        end

        cmd.on('-a', '--append',
               "When the rvpacker-txt or the game which files you've parsed receives an update,",
               'you probably should re-read game files with --append, which will append any new text to your files without overwriting the progress',
               'Cannot be used with --force',
               '[Read flag]') do
            raise '--append cannot be used with --force.' if options[:force]
            options[:append] = true
        end

        cmd.on('-h', '--help', 'Show help message') do
            puts cmd
            exit
        end
    end.parse!

    options[:action] = ARGV.shift
    raise 'COMMAND argument is required. Use rvpacker-txt -h for help.' if options[:action].nil?
    raise 'Invalid command. Allowed commands are: read, write.' unless %w[read write].include?(options[:action])

    options
end

# @param [String] system_file_path
# @return [String, nil]
def self.get_game_type(system_file_path)
    object = Marshal.load(File.binread(system_file_path))
    game_title = object.instance_variable_get(:@game_title).to_s.downcase
    game_title.include?('lisa') ? 'lisa' : nil
end

start_time = Time.now

options = parse_options
input_dir = options[:input_dir]
output_dir = options[:output_dir]
disable_custom_processing = options[:disable_custom_processing]
shuffle_level = options[:shuffle_level]
logging = options[:logging]
disable_processing = options[:disable_processing]
force = options[:force]
append = options[:append]

extensions = { xp: 'rxdata', vx: 'rvdata', ace: 'rvdata2' }

original_directory = Dir.glob(File.join(input_dir, '{data,original}'), File::FNM_CASEFOLD).first
raise '"Data" or "original" directory not found within input directory.' unless original_directory

maps_path = File.join(input_dir, 'translation', 'maps')
other_path = File.join(input_dir, 'translation', 'other')

FileUtils.mkdir_p(maps_path)
FileUtils.mkdir_p(other_path)

engine = extensions.each { |sym, ext| break sym if File.exist?(File.join(original_directory, "System.#{ext}")) } ||
    (raise "Couldn't determine project engine.")

files = Dir.glob("#{original_directory}/*#{extensions[engine]}")

maps_files_paths = []
other_files_paths = []
system_file_path = nil
scripts_file_path = nil

files.each do |file|
    basename = File.basename(file)
    next unless basename.end_with?(extensions[engine])

    if basename.start_with?(/Map[0-9]/)
        maps_files_paths.push(file)
    elsif !basename.start_with?(/Map|Tilesets|Animations|System|Scripts|Areas/)
        other_files_paths.push(file)
    elsif basename.start_with?('System')
        system_file_path = file
    elsif basename.start_with?('Scripts')
        scripts_file_path = file
    end
end

ini_file_path = File.join(input_dir, 'Game.ini')

game_type = disable_custom_processing ? nil : get_game_type(system_file_path)

wait_time = 0
processing_type = if force
                      wait_time_start = Time.now

                      puts "WARNING! You're about to forcefully rewrite all your translation files, including _trans files.",
                           "If you really want to do it, make sure you've made a backup of your _trans files, if you made some changes in them already.",
                           "Input 'Y' to continue."
                      exit unless gets.chomp == 'Y'

                      wait_time = Time.now - wait_time_start
                      :force
                  else
                      append ? :append : :default
                  end

puts 'Custom processing for this game is enabled. Use --disable-custom-processing to disable it.' unless game_type.nil?

if options[:action] == 'read'
    require 'read'
    read_map(maps_files_paths, maps_path, logging, game_type, processing_type) unless disable_processing[:maps]
    read_other(other_files_paths, other_path, logging, game_type, processing_type) unless disable_processing[:other]
    read_system(system_file_path, ini_file_path, other_path, logging, processing_type) unless disable_processing[:system]
    read_scripts(scripts_file_path, other_path, logging, processing_type) unless disable_processing[:scripts]
else
    require 'write'
    output_path = File.join(output_dir, 'output')
    FileUtils.mkdir_p(output_path)

    write_map(maps_files_paths, maps_path, output_path, shuffle_level, logging, game_type) unless disable_processing[:maps]
    write_other(other_files_paths, other_path, output_path, shuffle_level, logging, game_type) unless disable_processing[:other]
    write_system(system_file_path, ini_file_path, other_path, output_path, shuffle_level, logging) unless disable_processing[:system]
    write_scripts(scripts_file_path, other_path, output_path, logging) unless disable_processing[:scripts]
end

$wait_time = 0 if $wait_time.nil?
elapsed_time = Time.now - start_time - wait_time - $wait_time

puts "Done in #{elapsed_time}"
